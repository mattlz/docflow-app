import fs from 'fs-extra';
import path from 'path';

import { ProjectContext, GeneratedBundle } from '../types/conversation.js';

export class ProjectGenerator {
  async generate(context: ProjectContext, projectPath: string, templateRoot: string): Promise<void> {
    await this.createDirectories(projectPath);
    await this.copyTemplates(projectPath, templateRoot);
    await this.initializeTrackingFiles(context, projectPath);
  }

  private async createDirectories(projectPath: string): Promise<void> {
    await fs.ensureDir(projectPath);
  }

  private async copyTemplates(projectPath: string, templateRoot: string): Promise<void> {
    // templateRoot already points at the docflow template directory
    const docflowSrc = templateRoot;
    const cursorSrc = path.join(templateRoot, '.cursor');
    const docflowDest = path.join(projectPath, 'docflow');
    const cursorDest = path.join(projectPath, '.cursor');

    // Only copy the intended directories
    if (await fs.pathExists(docflowSrc)) {
      await fs.copy(docflowSrc, docflowDest, { overwrite: true, recursive: true });
      // Ensure no nested .cursor inside docflow
      const nestedCursor = path.join(docflowDest, '.cursor');
      if (await fs.pathExists(nestedCursor)) {
        await fs.remove(nestedCursor);
      }
    }
    if (await fs.pathExists(cursorSrc)) {
      await fs.copy(cursorSrc, cursorDest, { overwrite: true, recursive: true });
    } else {
      // Ensure a minimal .cursor directory exists even if template lacks it
      await fs.ensureDir(cursorDest);
    }

    // Cleanup: remove any accidentally copied root-level folders from older templates
    const strayContext = path.join(projectPath, 'context');
    const straySpecs = path.join(projectPath, 'specs');
    if (await fs.pathExists(strayContext)) {
      await fs.remove(strayContext);
    }
    if (await fs.pathExists(straySpecs)) {
      await fs.remove(straySpecs);
    }
  }

  private async initializeTrackingFiles(context: ProjectContext, projectPath: string): Promise<void> {
    const activePath = path.join(projectPath, 'docflow', 'ACTIVE.md');
    const indexPath = path.join(projectPath, 'docflow', 'INDEX.md');
    const activeDir = path.join(projectPath, 'docflow', 'specs', 'active');
    const backlogDir = path.join(projectPath, 'docflow', 'specs', 'backlog');
    const sharedDir = path.join(projectPath, 'docflow', 'shared');
    const now = new Date().toISOString().split('T')[0];

    await fs.ensureDir(activeDir);
    await fs.ensureDir(backlogDir);
    await fs.ensureDir(sharedDir);

    const active = `# Currently Active\n\n## Primary Focus\n- feature-project-setup - Project scaffolding and environment\n\n## Status\nProject created by DocFlow CLI on ${now}.\n`;
    const index = `# Feature Index\n\n## Active\n- feature-project-setup: Project setup and scaffolding (Started ${now})\n\n## Backlog Priority\n- [Populate via conversation]\n\n## Completed\n- [No completed items yet]\n`;

    await fs.outputFile(activePath, active);
    await fs.outputFile(indexPath, index);
  }

  async writeGeneratedFiles(bundle: GeneratedBundle, projectPath: string): Promise<void> {
    const ctxDir = path.join(projectPath, 'docflow', 'context');
    await fs.ensureDir(ctxDir);

    const toStringArray = (value: unknown): string[] => {
      if (Array.isArray(value)) return value.map((v) => String(v)).filter((s) => s.trim().length > 0);
      if (typeof value === 'string') return [value];
      return [];
    };

    const overviewMd = [
      '# Project Overview',
      '',
      '## Summary',
      (bundle.overview && bundle.overview.purpose) || '',
      '',
      '## Goals',
      ...toStringArray(bundle.overview && bundle.overview.features).map((f) => `- ${f}`),
      '',
      '## Non‑Goals',
      '- Keep scope focused on prototype; defer complex auth/payments/analytics',
      '',
      '## Risks & Assumptions',
      '- Tech choices may evolve during prototyping',
      '',
      '## Success Criteria',
      (bundle.overview && bundle.overview.success) || '',
      '',
      '## Notes',
      `Generated by DocFlow CLI for ${bundle.overview?.name || 'new project'}. Adjust as needed.`,
      '',
    ].join('\n');

    const stackMd = [
      '# Technology Stack',
      '',
      '## Frontend',
      ...toStringArray(bundle.stack && bundle.stack.frontend).map((s) => `- ${s}`),
      '',
      '## Backend',
      ...toStringArray(bundle.stack && bundle.stack.backend).map((s) => `- ${s}`),
      '',
      '## Database',
      ...toStringArray(bundle.stack && bundle.stack.database).map((s) => `- ${s}`),
      '',
      '## Infrastructure',
      ...toStringArray(bundle.stack && bundle.stack.infrastructure).map((s) => `- ${s}`),
      '',
      '## Development Tools',
      '- Linting/Formatting: ESLint, Prettier',
      '- Testing: Vitest (unit), basic integration later',
      '',
    ].join('\n');

    const standardsMd = [
      '# Standards & Setup',
      '',
      '## Initialization',
      typeof bundle.standards === 'string' ? bundle.standards.trim() : String(bundle.standards ?? ''),
      '',
      '## Conventions',
      '- TypeScript strict mode',
      '- Feature‑first specs; acceptance criteria must be testable',
      '- Keep changes small; avoid unrelated refactors',
      '',
      '## Testing',
      '- Unit tests for pure logic (Vitest)',
      '- Snapshots for templates where helpful',
      '',
      '## Git & Workflow',
      '- Conventional commits',
      '- Branch per spec; PRs reference spec name',
      '',
    ].join('\n');

    const activeSpecsDir = path.join(projectPath, 'docflow', 'specs', 'active');
    const backlogSpecsDir = path.join(projectPath, 'docflow', 'specs', 'backlog');
    await fs.ensureDir(activeSpecsDir);
    await fs.ensureDir(backlogSpecsDir);

    const specs = Array.isArray(bundle.specs) ? bundle.specs : [];

    // Ensure project-setup exists and goes to active
    const setup = specs.find((s) => (s.name || '').toLowerCase().includes('project-setup')) || {
      type: 'feature',
      name: 'project-setup',
      description: 'Initialize the project with core dependencies and DocFlow structure',
      acceptance: [
        'DocFlow structure present at project root (docflow/*)',
        'Tracking files ACTIVE.md and INDEX.md initialized',
        'Environment variables documented',
      ],
      priority: 1,
    };

    const otherSpecs = specs.filter((s) => s !== setup);

    // Write active project-setup first
    await this.writeSpecFile(activeSpecsDir, setup);

    // Write remaining specs to backlog
    for (const spec of otherSpecs) {
      const safeName = String(spec.name || 'unnamed').toLowerCase().replace(/[^a-z0-9-]/g, '-');
      await this.writeSpecFile(backlogSpecsDir, { ...spec, name: safeName });
    }

    await fs.outputFile(path.join(ctxDir, 'overview.md'), overviewMd);
    await fs.outputFile(path.join(ctxDir, 'stack.md'), stackMd);
    await fs.outputFile(path.join(ctxDir, 'standards.md'), standardsMd);
  }

  private async writeSpecFile(dir: string, spec: { type: string; name: string; description: string; acceptance: string[]; priority?: number }): Promise<void> {
    const titleType = spec.type === 'feature' ? 'Feature' : spec.type === 'bug' ? 'Bug' : 'Idea';
    const filenameSafe = String(spec.name || 'unnamed').toLowerCase().replace(/[^a-z0-9-]/g, '-');
    const md = [
      `# ${titleType}: ${filenameSafe}`,
      '',
      '## Context',
      spec.description || '',
      '',
      '## Acceptance Criteria',
      ...(Array.isArray(spec.acceptance) ? spec.acceptance : []).map((a) => `- [ ] ${a}`),
      '',
      '## Dependencies',
      '- None',
      '',
      '## Implementation Notes',
      '- Keep it simple; align with stack.md choices.',
      '',
      '## Priority',
      String(spec.priority ?? 3),
      '',
    ].join('\n');
    await fs.outputFile(path.join(dir, `${spec.type}-${filenameSafe}.md`), md);
  }
}


